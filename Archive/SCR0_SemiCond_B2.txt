
model{
 p0~dunif(0,1)
 alpha0<-logit(p0)
 sigma~dunif(0,10)
 alpha1 <- 1/(2*sigma*sigma)

 #prior for N
 # Posterior conditional distribution for N-n (and hence N):
  n0 ~ dnegbin(pstar,n)
  N <- n + n0

 #Probability of capture for integration grid points
 #pdot = probability of being detected at least once (given location)
 for(g in 1:Gpts){    # Gpts= number of points on integration grid
  for(k in 1:K){      # K = number of occasions
   for(j in 1:J){     # J = number of traps
    one_minus_detprob[g,k,j] <- 1 - p0*exp(-alpha1*Gdist[g,j]*Gdist[g,j]) #Gdist given as data
   }
  }
  pdot.temp[g] <- 1 - prod(one_minus_detprob[g,,])
  pdot[g] <- max(pdot.temp[g], 1.0E-10)             #prob of ever detected | location at G[g]
 }
 pstar <- (sum(pdot[1:Gpts])*a)/Area                #prob of detecting an individual in S (a=area of each integration grid) 

 # Zero trick for initial 1/pstar^n
  loglikterm <- -n * log(pstar)
  lambda <- -loglikterm + 1000
  dummy ~ dpois(lambda) # dummy = 0; entered as data


 for(i in 1:n){
  s[i,1] ~ dunif(xlim[1],xlim[2])
  s[i,2] ~ dunif(ylim[1],ylim[2])
  for(j in 1:J){
   y[i,j] ~ dbin(p[i,j],K)
   d[i,j] <- pow(pow(s[i,1]-X[j,1],2) + pow(s[i,2]-X[j,2],2),0.5)
   p[i,j] <- p0*exp(- alpha1*d[i,j]*d[i,j])
  }#J
 }#i
}
