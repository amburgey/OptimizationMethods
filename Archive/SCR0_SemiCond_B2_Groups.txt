
model{

 sigma~dunif(0,100)
 alpha1 <- 1/(2*sigma*sigma)

for(b in 1:B){
 #prior for intercept
 p0[b]~dunif(0,1)
 alpha0[b]<-logit(p0[b])

 #prior for N
 # Posterior conditional distribution for N-n (and hence N):
  n0[b] ~ dnegbin(pstar[b],ngroup[b])
  Ngroup[b] <- ngroup[b] + n0[b]
}
N <- sum(Ngroup[1:B])

 #Probability of capture for integration grid points
 #pdot = probability of being detected at least once (given location)
 for(b in 1:B){
  for(g in 1:Gpts){    # Gpts= number of points on integration grid
   for(k in 1:K){      # K = number of occasions
    for(j in 1:J){     # J = number of traps
     one_minus_detprob[g,k,j,b] <- 1 - p0[b]*exp(-alpha1*Gdist[g,j]*Gdist[g,j]) #Gdist given as data
    }#j
   }#k
  pdot.temp[g,b] <- 1 - prod(one_minus_detprob[g,,,b])
  pdot[g,b] <- max(pdot.temp[g,b], 1.0E-10)             #prob of ever detected | location at G[g]
 }#g
 pstar[b] <- (sum(pdot[1:Gpts,b])*a)/Area                #prob of detecting an individual in S (a=area of each integration grid) 

 # Zero trick for initial 1/pstar^n
  loglikterm[b] <- -ngroup[b] * log(pstar[b])
  lambda[b] <- -loglikterm[b] + 1000
  dummy[b] ~ dpois(lambda[b]) # dummy = rep(0, B), entered as data
 }#b

 for(i in 1:n){
  s[i,1] ~ dunif(xlim[1],xlim[2])
  s[i,2] ~ dunif(ylim[1],ylim[2])
  for(j in 1:J){
   y[i,j] ~ dbin(p[i,j],K)
   d[i,j] <- pow(pow(s[i,1]-X[j,1],2) + pow(s[i,2]-X[j,2],2),0.5)
   p[i,j] <- p0[size[i]]*exp(- alpha1*d[i,j]*d[i,j])
  }#J
 }#i

 # derived proportion in each size class
 for(b in 1:B){
  piGroup[b] <- Ngroup[b]/N
 }

}
