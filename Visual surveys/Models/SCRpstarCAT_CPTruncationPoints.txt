
model {

  sigma ~ dunif(0,100)
  alpha1 <- 1/(2*sigma*sigma)
  # prior prob for each grid cell (setting b[1:Gpts] = rep(1,Gpts) is a uniform prior across all cells)
  pi[1:Gpts] ~ ddirch(b[1:Gpts])
  #prior for intercept
  p0 ~ dunif(0,5)

  # Posterior conditional distribution for N-n (and hence N):
  n0 ~ dnegbin(pstar,n)  # number of failures
  N <- n + n0

  #Probability of capture for integration grid points
  #pdot = probability of being detected at least once (given location)

  for(g in 1:Gpts){ # Gpts = number of points on integration grid
    for(j in 1:J){  # J = number of traps
      #Probability of an individual being missed at grid cell g and trap j multiplied by total effort (K) at that trap
      miss_allK[g,j] <- pow((1 - p0*exp(-alpha1*Gdist[g,j]*Gdist[g,j])),K[j])
    } #J
    pdot.temp[g] <- 1 - prod(miss_allK[g,]) #Prob of detect across entire study area and time period
    pdot[g] <- max(pdot.temp[g], 1.0E-10)  #pdot.temp is very close to zero and will lock model up with out this
  } #G
  pstar <- (sum(pdot[1:Gpts]*a[1:Gpts]))/A #prob of detecting at least once in S (a=area of each integration grid, given as data)

  # Zero trick for initial 1/pstar^n
  loglikterm <- -n * log(pstar)
  lambda <- -loglikterm + 10000
  dummy ~ dpois(lambda) # dummy = 0; entered as data

  for(i in 1:n){  ## n = number of observed individuals
    ## For use when defining traps on a grid cell
    s[i] ~ dcat(pi[1:Gpts])

    # Model for capture histories of observed individuals:
    for(j in 1:J){  ## J = number of traps
      y[i,j] ~ dpois(p[i,j]*K[j])
      p[i,j] <- p0*exp(-alpha1*Gdist[s[i],j]*Gdist[s[i],j])
    }#J
  }#I
}
